/* Copyright 2021, 2022, 2023 Rune Berg (GitHub: https://github.com/1runeberg, Twitter: https://twitter.com/1runeberg, YouTube: https://www.youtube.com/@1RuneBerg)
 *
 *  SPDX-License-Identifier: MIT
 *
 *  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *  DAMAGE.
 *
 */

#include <cstdlib>
#include <iomanip>
#include <iostream>

#include <openxr_provider.h>

#include "renderer_vulkan.h"

// Generated by cmake by populating project_config.h.in
#include "project_config.h"

#define APP_NAME "sample_03_hello_exts"
#define ENGINE_NAME "openxr_provider"

#define LOG_CATEGORY "OpenXRProviderDemo"

// global vars
XrEventDataBaseHeader *g_xrEventDataBaseheader = nullptr;

#ifdef XR_USE_PLATFORM_ANDROID
XrResult demo_openxr_init( struct android_app *app )
#else
XrResult demo_openxr_init()
#endif
{
	// (1) Create a openxr provider object that we'll use to communicate with the openxr runtime.
	//     You can optionally set a default log level during creation.
	std::unique_ptr< oxr::Provider > oxrProvider = std::make_unique< oxr::Provider >( oxr::ELogLevel::LogDebug );

	// For Android, we need to first initialize the android openxr loader
#ifdef XR_USE_PLATFORM_ANDROID
	if ( !XR_UNQUALIFIED_SUCCESS( oxrProvider->InitAndroidLoader( app ) ) )
	{
		oxr::LogError( LOG_CATEGORY, "FATAL! Unable to load Android OpenXR Loader in this device!" );
		return XR_ERROR_RUNTIME_UNAVAILABLE;
	}
#endif

	// (2) Check requested extensions against supported extensions from the current runtime
	//     We will use this later when initializing an openxr instance
	//     In this sample, we'll try to check for and enable some useful extensions if available:
	//     https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#XR_KHR_visibility_mask
	//	   https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#XR_KHR_composition_layer_depth
	//     https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#XR_EXT_dpad_binding
	//
	// 	   If you do not specify a vulkan graphics api extension, then the provider will choose the best one
	//     from what's available from the runtime. In this case, you can use GetCurrentVulkanExt() check which
	//
	//	   You can also manually request available runtime extensions with GetSupportedExtensions()
	//     Similar functions are available for api layers

	std::vector< const char * > vecRequestedExtensions {
		XR_KHR_VULKAN_ENABLE_EXTENSION_NAME, XR_KHR_VISIBILITY_MASK_EXTENSION_NAME, XR_KHR_COMPOSITION_LAYER_DEPTH_EXTENSION_NAME, XR_EXT_DPAD_BINDING_EXTENSION_NAME };

	oxrProvider->FilterOutUnsupportedExtensions( vecRequestedExtensions );

	// (3) Set the application info that the openxr runtime will need in order to initialize an openxr instance
	oxr::AppInstanceInfo oxrAppInstanceInfo {};
	oxrAppInstanceInfo.sAppName = APP_NAME;
	oxrAppInstanceInfo.unAppVersion = OXR_MAKE_VERSION32( SAMPLE3_VERSION_MAJOR, SAMPLE3_VERSION_MINOR, SAMPLE3_VERSION_PATCH );
	oxrAppInstanceInfo.sEngineName = ENGINE_NAME;
	oxrAppInstanceInfo.unEngineVersion = OXR_MAKE_VERSION32( PROVIDER_VERSION_MAJOR, PROVIDER_VERSION_MINOR, PROVIDER_VERSION_PATCH );
	oxrAppInstanceInfo.vecInstanceExtensions = vecRequestedExtensions;

	// (4) Initialize the provider - this will create an openxr instance with the current default openxr runtime.
	//     If there's no runtime or something has gone wrong, the provider will return an error code
	//			from https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#return-codes
	//     Notice that you can also use native openxr data types (e.g. XrResult) directly

	XrResult xrResult = oxrProvider->Init( &oxrAppInstanceInfo );
	if ( XR_UNQUALIFIED_SUCCESS( xrResult ) )
	{
		oxr::LogInfo( LOG_CATEGORY, "OpenXr instance created with handle (%" PRIu64 ")", ( uint64_t )oxrProvider->GetOpenXrInstance() );
	}
	else
	{
		// The provider will add a log entry for the error, or optionally handle it,
		//	here we're just logging it again and using a nifty stringify function (only for openxr enums).
		oxr::LogError( LOG_CATEGORY, "Error encountered while creating an openxr instance  (%s)", oxr::XrEnumToString( xrResult ) );
		return xrResult;
	}

	// (5) Setup vulkan renderer and create openxr graphics binding
	std::unique_ptr< VulkanRenderer > pRenderer = std::make_unique< VulkanRenderer >();
	xrResult = pRenderer->Init( oxrProvider.get(), &oxrAppInstanceInfo );

	// (6) Create openxr session
	xrResult = oxrProvider->CreateSession( pRenderer->GetVulkanGraphicsBinding() );
	if ( XR_UNQUALIFIED_SUCCESS( xrResult ) )
	{
		oxr::LogInfo( LOG_CATEGORY, "OpenXr session created with handle (%" PRIu64 ")", ( uint64_t )oxrProvider->Session()->GetXrSession() );
	}
	else
	{
		oxr::LogError( LOG_CATEGORY, "Error creating openxr session with result (%s) ", oxr::XrEnumToString( xrResult ) );
		return xrResult;
	}

	// Main game loop
	while ( oxrProvider->Session()->GetState() != XR_SESSION_STATE_EXITING )
	{
		// (7) Poll runtime for openxr events
		g_xrEventDataBaseheader = oxrProvider->PollXrEvents();

		if ( g_xrEventDataBaseheader )
		{
			// Handle session state changes
			if ( g_xrEventDataBaseheader->type == XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED )
			{
				if ( oxrProvider->Session()->GetState() == XR_SESSION_STATE_READY )
				{
					// (7.1) Start session - begin the app's frame loop here
					oxr::LogInfo( LOG_CATEGORY, "App frame loop starts here." );
					xrResult = oxrProvider->Session()->Begin(); // defaults to stereo (vr)
				}
				else if ( oxrProvider->Session()->GetState() == XR_SESSION_STATE_STOPPING )
				{
					// (7.2) End session - end the app's frame loop here
					oxr::LogInfo( LOG_CATEGORY, "App frame loop ends here." );
					oxrProvider->Session()->End();
				}
			}
		}
	}

	// (8) Cleanup - this will cleanly destroy all openxr objects
	oxrProvider.release();

	return xrResult;
}

#ifdef XR_USE_PLATFORM_ANDROID
/**
 * This is the main entry point of a native application that is using
 * android_native_app_glue.  It runs in its own thread, with its own
 * event loop for receiving input events and doing other things.
 */
void android_main( struct android_app *app )
{
	// Attach environment to thread
	JNIEnv *Env;
	app->activity->vm->AttachCurrentThread( &Env, nullptr );

	// Create instance
	demo_openxr_init( app );

	return;
}

#else
int main( int argc, char *argv[] )
{
	// Debugging
	std::cout << "Argument count [argc] == " << argc << '\n';
	for ( uint32_t i = 0; i != argc; ++i )
	{
		std::cout << "argv[" << i << "] == " << std::quoted( argv[ i ] ) << '\n';
	}
	std::cout << "argv[" << argc << "] == " << static_cast< void * >( argv[ argc ] ) << '\n';

	std::cout << "\n\nPress enter to start. This is also a good time to attach a debugger if you need to.";
	std::cin.get();

	// Create instance
	demo_openxr_init();

	// Manual for debug sessions
	std::cout << "\n\nPress enter to end.";
	std::cin.get();

	return EXIT_SUCCESS;
}
#endif
