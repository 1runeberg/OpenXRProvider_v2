/* Copyright 2021, 2022, 2023 Rune Berg (GitHub: https://github.com/1runeberg, Twitter: https://twitter.com/1runeberg, YouTube: https://www.youtube.com/@1RuneBerg)
 *
 *  SPDX-License-Identifier: MIT
 *
 *  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *  DAMAGE.
 *
 */

#pragma once
#include "common.hpp"

#define LOG_CATEGORY_SESSION "OpenXRProvider-Session"

class Provider;
namespace oxr
{
	// Callback function pointer to apps rendering operations
	typedef void ( *Callback_RenderImage )( uint32_t, uint32_t );

	// Data packet for a render callback
	struct RenderImageCallback
	{
		// The swapchain index for this callback
		uint32_t unSwapchainIndex;

		// The image index for this callback
		uint32_t unImageIndex;

		// Function pointer to the app's render callback function to execute
		Callback_RenderImage fnCallback;
	};

	// Set of vulkan texture formats that will be used for renders
	struct TextureFormats
	{
		// Will hold the selected vulkan color texture format that will be used for the openxr session
		VkFormat vkColorTextureFormat = VK_FORMAT_UNDEFINED;

		// Will hold the selected depth texture format that will be used for the openxr session
		VkFormat vkDepthTextureFormat = VK_FORMAT_UNDEFINED;
	};

	// Convenience struct for handling an openxr swapchains
	struct Swapchain
	{
		// Color and depth texture formats used by these swapchains
		TextureFormats vulkanTextureFormats { VK_FORMAT_UNDEFINED, VK_FORMAT_UNDEFINED };

		// The openxr color swapchain handle
		XrSwapchain xrColorSwapchain = XR_NULL_HANDLE;

		// The openxr depth swapchain handle
		XrSwapchain xrDepthSwapchain = XR_NULL_HANDLE;

		// Swapchain image width - this is  assumed uniform for all images in the swapchains
		int32_t unWidth = 0;

		// Swapchain image height - this is  assumed uniform for all images in the swapchains
		int32_t unHeight = 0;

		// Color swapchain images/textures generated by the currently active runtime
		std::vector< XrSwapchainImageVulkan2KHR > vecColorTextures;

		// Depth swapchain images/textures generated by the currently active runtime
		std::vector< XrSwapchainImageVulkan2KHR > vecDepthTextures;

		Swapchain() {};
		~Swapchain()
		{
			vecColorTextures.clear();
			vecDepthTextures.clear();
		}
	};

	class Session
	{
	  public:
		/// <summary>
		/// Creates a Session class native to this library that holds convenience functions and openxr state handling
		/// </summary>
		/// <param name="pInstance">Pointer to the instance state struct. An instance must be created and initialized before a session is created</param>
		/// <param name="eLogLevel">Severity level to be used for logging</param>
		/// <param name="bDepthHandling">Whether a special depth handlign extension is active</param>
		Session( oxr::Instance *pInstance, ELogLevel eLogLevel, bool bDepthHandling = false );
		~Session()
		{

			for ( Swapchain swapchain : m_vecSwapchains )
			{
				xrDestroySwapchain( swapchain.xrColorSwapchain );
			}

			if ( m_xrReferenceSpace != XR_NULL_HANDLE )
			{
				xrDestroySpace( m_xrReferenceSpace );
			}

			if ( m_xrAppSpace != XR_NULL_HANDLE )
			{
				xrDestroySpace( m_xrAppSpace );
			}

			if ( m_xrSession != XR_NULL_HANDLE )
			{
				xrDestroySession( m_xrSession );
			}
		}

		/// <summary>
		/// Creates an openxr session. This is normally called by the provider class, but exposed in public for flexibility.
		/// </summary>
		/// <param name="pSessionCreateInfo">openxr create info struct neeed to create an openxr session. The provider class have convenience functions to generate this</param>
		/// <returns>The result returned by the openxr runtime when creating an openxr session</returns>
		XrResult Init( XrSessionCreateInfo *pSessionCreateInfo );

		/// <summary>
		/// Checks a boolean result from a function call that doesn't return an XrResult ( e.g. bool foo(XrResult xrResult) {} ).
		/// Logs the XrResult if the boolean return value is false
		/// </summary>
		/// <param name="bTest">The boolean result from a fucntion call with XrResult as an out parameter</param>
		/// <param name="xrErrorIfFail">The XrError to log if failed (filled in by the function call as an out parameter)</param>
		/// <param name="pccErrorMsg">The error message to log</param>
		/// <returns></returns>
		XrResult CheckIfXrError( bool bTest, XrResult xrErrorIfFail, const char *pccErrorMsg );

		/// <summary>
		/// Check if the Init() function for this class has been called.
		/// </summary>
		/// <returns>Return an error as an XrResult and inform the app that it needs to call init first</returns>
		XrResult CheckIfInitCalled();

		/// <summary>
		/// Retrieves the active openxr session handle
		/// </summary>
		/// <returns>The active openxr session handle</returns>
		XrSession GetXrSession() { return m_xrSession; }

		/// <summary>
		/// Retrieves the current openxr session state (e.g. VISIBLE, FOCUSED, etc)
		/// </summary>
		/// <returns>The current openxr session state</returns>
		XrSessionState GetState() { return m_xrSessionState; }
		void SetState( XrSessionState xrSessionState ) { m_xrSessionState = xrSessionState; }

		/// <summary>
		/// Checks whether special depth handling extension/s is/are active
		/// </summary>
		/// <returns>Whether special depth handling extension/s is/are active</returns>
		bool IsDepthSupported() { return m_bDepthHandling; }

		/// <summary>
		/// Utility function for app to determine if an openxr session is active - rendering frames at least
		/// </summary>
		/// <returns>True if the current openxr session is at least rendering frames, false otherwise</returns>
		bool IsSessionRunning() { return GetState() < XR_SESSION_STATE_VISIBLE; }

		/// <summary>
		/// Starts the openxr session. Init() must be called first and use PollXrEvents to check if session state is in the READY state.
		/// All parameters are optional, default view type is stereo for VR apps
		/// </summary>
		/// <param name="xrViewConfigurationType">View configuration type to use for the session. Make sure it's supported by the active runtime via Provider::GetSupportedViewConfigurations()</param>
		/// <param name="xrRefSpaceType">Reference space type - normally STAGE. Use VIEW for the eye pose(s)</param>
		/// <param name="xrReferencePose">Origin pose for the reference space</param>
		/// <param name="pvOtherBeginInfo">Optional other session begin info</param>
		/// <param name="pvOtherReferenceSpaceInfo">Optional other reference space info</param>
		/// <returns>The result returned by the runtime for starting an openxr session</returns>
		XrResult Begin(
			XrViewConfigurationType xrViewConfigurationType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,
			XrReferenceSpaceType xrRefSpaceType = XR_REFERENCE_SPACE_TYPE_STAGE,
			XrPosef xrReferencePose = IdentityPosef(),
			void *pvOtherBeginInfo = nullptr,
			void *pvOtherReferenceSpaceInfo = nullptr );

		/// <summary>
		/// Ends the active openxr session - effectively telling the runtime that the app won't render or require input from this point on
		/// </summary>
		/// <returns>Result from the openxr runtime when attempting to end an openxr session</returns>
		XrResult End();

		/// <summary>
		/// Request the runtime to cycle properly through the openxr session states to end the session.
		/// This is normally useful for apps where session state is handled by the device's system - e.g. Android
		/// </summary>
		/// <returns>Result from the runtime when attempting to exit the session</returns>
		XrResult RequestExit();

		/// <summary>
		/// Retrieves the reference space types supported by the active openxr runtime (e.g. STAGE for VR apps)
		/// </summary>
		/// <returns>Vector if reference space types supported by the active openxr runtime</returns>
		std::vector< XrReferenceSpaceType > GetSupportedReferenceSpaceTypes();

		/// <summary>
		/// Create a reference space of a give type. Use this to create origin offsets for objects to be rendered in the scene
		/// </summary>
		/// <param name="outSpace">Output parameter that will hold the XrSpace handle</param>
		/// <param name="xrReferenceSpaceType">The reference space type to create</param>
		/// <param name="xrReferencePose">Offset from origin/reference for this space</param>
		/// <param name="pvAdditionalCreateInfo">Optional other info needed to create the reference space</param>
		/// <returns>Result from the runtime on attempting to createaa reference space</returns>
		XrResult CreateReferenceSpace( XrSpace *outSpace, XrReferenceSpaceType xrReferenceSpaceType, XrPosef xrReferencePose, void *pvAdditionalCreateInfo = nullptr );

		/// <summary>
		/// Retrieves the current pose and metadata for the provided reference space
		/// </summary>
		/// <param name="baseSpace">The origin/reference space</param>
		/// <param name="targetSpace">The space to get the pose and metadata of</param>
		/// <param name="predictedDisplayTime">Display time the pose is to be rendered</param>
		/// <param name="outSpaceLocation">Output parameter for the pose and metadata</param>
		/// <returns>Result from the openxr runtime of retrieving the pose and metadata for the provided space</returns>
		XrResult LocateSpace( XrSpace baseSpace, XrSpace targetSpace, XrTime predictedDisplayTime, XrSpaceLocation *outSpaceLocation );

		/// <summary>
		/// Convenience function to get the session's reference space pose
		/// </summary>
		/// <param name="predictedDisplayTime">Display time the pose is to be rendered</param>
		/// <param name="outSpaceLocation">Output parameter for the reference pose and metadata</param>
		/// <returns>Result from the openxr runtime of retrieving the pose and metadata for the reference space</returns>
		XrResult LocateReferenceSpace( XrTime predictedDisplayTime, XrSpaceLocation *outSpaceLocation );

		/// <summary>
		/// Convenience function to get the application's reference space pose (world origin for rendering)
		/// </summary>
		/// <param name="predictedDisplayTime">Display time the pose is to be rendered</param>
		/// <param name="outSpaceLocation">Output parameter for the reference pose and metadata</param>
		/// <returns>Result from the openxr runtime of retrieving the pose and metadata for the app space</returns>
		XrResult LocateAppSpace( XrTime predictedDisplayTime, XrSpaceLocation *outSpaceLocation );

		/// <summary>
		/// Updates the cache for the supported view configuration views by the currently active openxr runtime
		/// This defines the runtime recommended texture sizes/extents as well the maximums.
		/// </summary>
		/// <param name="outResult">Output parameter for the XrResult returned by the runtime for retrieving hte supported view configuration views</param>
		/// <param name="xrViewConfigType">The view config type to check for (e.g. STEREO for vr)</param>
		/// <returns>Vector of XrViewConfigurationView cache</returns>
		const std::vector< XrViewConfigurationView > &UpdateConfigurationViews( XrResult *outResult, XrViewConfigurationType xrViewConfigType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO );

		/// <summary>
		/// Retrieves the cached views - this holds information for the most recent pose and fov needed for matrix creation/calculations
		/// </summary>
		/// <returns>Vector of cached XrView</returns>
		const std::vector< XrView > &GetViews() { return m_vecViews; }

		/// <summary>
		/// Verifies if a given vulkan format is meant for depth
		/// </summary>
		/// <param name="vkFormat">The format to check</param>
		/// <returns>True if the given format is for depth, false otherwise</returns>
		bool IsDepthFormat( VkFormat vkFormat );

		/// <summary>
		/// Retrieves the active openxr runtime's supported vulkan texture formats
		/// </summary>
		/// <param name="outSupportedFormats">Output parameter vector that will hold the supported vulkan formats</param>
		/// <returns>Result from the runtime of retrievign the supported texture formats</returns>
		XrResult GetSupportedTextureFormats( std::vector< int64_t > &outSupportedFormats );

		/// <summary>
		/// Select a vulkan format from a list of supported vulkan formats and a list of requested formats by the app
		/// </summary>
		/// <param name="vecSupportedFormats">The runtime's supported vulkan formats. Retrieve from GetSupportedTextureFormats()</param>
		/// <param name="vecRequestedFormats">Vector of requested vulkan formats that will be checked FIFO</param>
		/// <param name="bIsDepth">Set to true to select an appropriate depth format</param>
		/// <returns>Selected vulkan format</returns>
		VkFormat SelectTextureFormat( std::vector< int64_t > &vecSupportedFormats, const std::vector< int64_t > &vecRequestedFormats, bool bIsDepth = false );

		/// <summary>
		/// Retrieves the cached created swapchains and metadata
		/// </summary>
		/// <returns>Cached swapchains and metadata</returns>
		const std::vector< Swapchain > &GetSwapchains() { return m_vecSwapchains; }

		/// <summary>
		/// Request the runtime to creates the images/textures for the swapchain (color textures by default)
		/// This will use the runtime's recommended number of textures per swapchain
		/// </summary>
		/// <param name="bIsDepth">When set to true, will generate the depth images/textures</param>
		/// <returns>Result from the openxr runtime when trying to create the images/textures for the swapchain</returns>
		XrResult CreateSwapchainImages( bool bIsDepth = false );

		/// <summary>
		/// Create swapchains for the openxr session. By default, one swapchain per view (in VR, this translates to one swapchain per eye)
		/// Custom amount of swapchains can also be requested, for example if the app wants to generate a single swapchain in vr instead of per eye
		/// The app will then render to a single texture both eyes (or use texture arrays) and specify the extents for each (i.e. single pass rendering)
		///
		/// For simplicity, the only required parameters are the output selected texture formats and requested texture formats
		/// Other parameters, such as texture sizes are gonna be derived from the runtime's recommendations and most frequent configs
		/// </summary>
		/// <param name="outSelectedTextureFormats">Output parameter of the selected texture formats that will be used in the openxr session</param>
		/// <param name="vecRequestedColorFormats">Requested texture color formats that will be tried in FIFO basis</param>
		/// <param name="vecRequestedDepthFormats">Requested texture depth formats that will be tried in FIFO basis</param>
		/// <param name="unWidth">Requested texture width. 0 will use the runtime's reccomendation</param>
		/// <param name="unHeight">Requested texture height. 0 will use the runtime's reccomendation</param>
		/// <param name="xrViewConfigType">The vieww configuration type (e.g. STEREO for VR). Make sure the active runtime supports the requested view configuration type</param>
		/// <param name="unSwapchainCount">Number of swpachains to create. Note that each swapchain holds an openxr color and depth swapchain as a pair</param>
		/// <param name="unArraysize">Array size for the textures (e.g. single pass rendering with a single texture and one subimage for each eye)</param>
		/// <param name="unSampleCount">Texture sample count</param>
		/// <param name="unFaceCount">Texture face count</param>
		/// <param name="unMipCount">Texture mip count</param>
		/// <returns>Result of the runtime attempting to create the requested swapchain configuration</returns>
		XrResult CreateSwapchains(
			TextureFormats *outSelectedTextureFormats,
			const std::vector< int64_t > &vecRequestedColorFormats,
			const std::vector< int64_t > &vecRequestedDepthFormats,
			uint32_t unWidth = 0,
			uint32_t unHeight = 0,
			XrViewConfigurationType xrViewConfigType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,
			uint32_t unSwapchainCount = 0,
			uint32_t unArraysize = 1,
			uint32_t unSampleCount = 0,
			uint32_t unFaceCount = 1,
			uint32_t unMipCount = 1 );

		/// <summary>
		/// Call to start rendering frames. Make sure to register for rendering callbacks (e.g. RegisterAcquireSwapchainImageImageCallback, etc)
		/// These will be called in the appropriate times during the openxr render pass
		/// </summary>
		/// <param name="vecFrameLayerProjectionViews">Vector fo projection layers to render</param>
		/// <param name="pFrameState">Output parameter for the framestate (e.g. for checking if the app should render in this pass)</param>
		/// <param name="xrEnvironmentBlendMode">Blend mode in this render</param>
		/// <param name="xrRectOffset">Rect offset (e.g. for single pass rendering or lowering res during runtime)</param>
		/// <param name="xrRectExtent">Rect extent (e.g. for single pass rendering or lowering res during runtime)</param>
		/// <param name="bIsarray">Whether texture to render to is an array</param>
		/// <param name="unArrayIndex">Index if a texture array</param>
		void RenderFrame(
			std::vector< XrCompositionLayerProjectionView > &vecFrameLayerProjectionViews,
			XrFrameState *pFrameState,
			XrEnvironmentBlendMode xrEnvironmentBlendMode = XR_ENVIRONMENT_BLEND_MODE_OPAQUE, // vr
			XrOffset2Di xrRectOffset = { 0, 0 },
			XrExtent2Di xrRectExtent = { 0, 0 },
			bool bIsarray = false,
			uint32_t unArrayIndex = 0 );

		/// <summary>
		/// Call to start rendering frames. Make sure to register for rendering callbacks (e.g. RegisterAcquireSwapchainImageImageCallback, etc)
		/// These will be called in the appropriate times during the openxr render pass
		/// </summary>
		/// <param name="vecFrameLayerProjectionViews">Vector of projection layers to render</param>
		/// <param name="vecFrameLayers">Vector of frame layers to render</param>
		/// <param name="pFrameState">Output parameter for the framestate (e.g. for checking if the app should render in this pass)</param>
		/// <param name="xrEnvironmentBlendMode">Blend mode in this render</param>
		/// <param name="xrRectOffset">Rect offset (e.g. for single pass rendering or lowering res during runtime)</param>
		/// <param name="xrRectExtent">Rect extent (e.g. for single pass rendering or lowering res during runtime)</param>
		/// <param name="bIsarray">Whether texture to render to is an array</param>
		/// <param name="unArrayIndex">Index if a texture array</param>
		void RenderFrame(
			std::vector< XrCompositionLayerProjectionView > &vecFrameLayerProjectionViews,
			std::vector< XrCompositionLayerBaseHeader* > &vecFrameLayers,
			XrFrameState *pFrameState,
			XrEnvironmentBlendMode xrEnvironmentBlendMode = XR_ENVIRONMENT_BLEND_MODE_OPAQUE, // vr
			XrOffset2Di xrRectOffset = { 0, 0 },
			XrExtent2Di xrRectExtent = { 0, 0 },
			bool bIsarray = false,
			uint32_t unArrayIndex = 0 );

		/// <summary>
		/// Retrieve the most recent predicted display time from the openxr runtime
		/// </summary>
		/// <returns>The most recent predicted display time from the openxr runtime</returns>
		XrTime GetPredictedDisplayTime() { return m_xrPredictedDisplayTime; }

		/// <summary>
		/// Retrieve the most recent predicted display period from the openxr runtime
		/// e.g. can be used for estimating display time for rendering ahead
		/// </summary>
		/// <returns>The most recent predicted display period from the openxr runtime</returns>
		XrTime GetPredictedDisplayPeriod() { return m_xrPredictedDisplayPeriod; }

		/// <summary>
		/// Retrieves the reference space handle for this session
		/// </summary>
		/// <returns>The reference space handle for this session</returns>
		XrSpace GetReferenceSpace() { return m_xrReferenceSpace; }

		/// <summary>
		/// Retrieve the application's reference space handle
		/// </summary>
		/// <returns>The application's reference space handle</returns>
		XrSpace GetAppSpace() { return m_xrReferenceSpace; }

		/// <summary>
		/// Get an identity pose
		/// </summary>
		/// <returns>Identity pose</returns>
		static inline XrPosef IdentityPosef()
		{
			XrPosef xrPose {};
			xrPose.orientation.w = 1;
			return xrPose;
		}

		/// <summary>
		/// Adds a function pointer from the app that will be called by the library after acquiring a swapchain image
		/// </summary>
		/// <param name="pRenderImageCallback">Function pointer to the callback</param>
		inline void RegisterAcquireSwapchainImageImageCallback( RenderImageCallback *pRenderImageCallback ) { m_vecAcquireSwapchainImageCallbacks.push_back( pRenderImageCallback ); }

		/// <summary>
		/// Removes a function pointer callback that will be called by the library after acquiring a swapchain image
		/// </summary>
		/// <param name="pRenderImageCallback">The callback to remove</param>
		inline void DeregisterAcquireSwapchainImageCallback( RenderImageCallback *pRenderImageCallback ) { DeregisterRenderImageCallback( m_vecAcquireSwapchainImageCallbacks, pRenderImageCallback ); }

		/// <summary>
		/// Adds a function pointer from the app that will be called by the library after waiting for a swapchain image
		/// </summary>
		/// <param name="pRenderImageCallback">Function pointer to the callback</param>
		inline void RegisterWaitSwapchainImageImageCallback( RenderImageCallback *pRenderImageCallback ) { m_vecWaitSwapchainImageCallbacks.push_back( pRenderImageCallback ); }

		/// <summary>
		/// Removes a function pointer callback that will be called by the library after waiting for a swapchain image
		/// </summary>
		/// <param name="pRenderImageCallback">The callback to remove</param>
		inline void DeregisterWaitSwapchainImageCallback( RenderImageCallback *pRenderImageCallback ) { DeregisterRenderImageCallback( m_vecWaitSwapchainImageCallbacks, pRenderImageCallback ); }

		/// <summary>
		/// Removes a function pointer callback that will be called by the library after releasing a swapchain image
		/// </summary>
		/// <param name="pRenderImageCallback">Function pointer to the callback</param>
		inline void RegisterReleaseSwapchainImageImageCallback( RenderImageCallback *pRenderImageCallback ) { m_vecReleaseSwapchainImageCallbacks.push_back( pRenderImageCallback ); }

		/// <summary>
		/// Removes a function pointer callback that will be called by the library after releasing a swapchain image
		/// </summary>
		/// <param name="pRenderImageCallback">The callback to remove</param>
		inline void DeregisterReleaseSwapchainImageCallback( RenderImageCallback *pRenderImageCallback ) { DeregisterRenderImageCallback( m_vecReleaseSwapchainImageCallbacks, pRenderImageCallback ); }

		/// <summary>
		/// Retrieves all the registered application callbacks to call after acquiring an image from the runtime
		/// </summary>
		/// <returns>The registered application callbacks to call after acquiring an image from the runtime</returns>
		const std::vector< RenderImageCallback * > &GetAcquireSwapchainImageCallbacks() { return m_vecAcquireSwapchainImageCallbacks; }

		/// <summary>
		/// Retrieves all the registered application callbacks to call after waiting for an image from the runtime
		/// </summary>
		/// <returns>The registered application callbacks to call after waiting for an image from the runtime</returns>
		const std::vector< RenderImageCallback * > &GetWaitSwapchainImageCallbacks() { return m_vecWaitSwapchainImageCallbacks; }

		/// <summary>
		/// Retrieves all the registered application callbacks to call after releasing an image from the runtime
		/// </summary>
		/// <returns>The registered application callbacks to call after waiting for an image from the runtime</returns>
		const std::vector< RenderImageCallback * > &GetReleaseSwapchainImageCallbacks() { return m_vecReleaseSwapchainImageCallbacks; }

	  private:
		// Current severity for logging
		ELogLevel m_eMinLogLevel = ELogLevel::LogInfo;

		// Category to use for logging
		std::string m_sLogCategory = LOG_CATEGORY_SESSION;

		// Pointer to instance state from the Provider class
		Instance *m_pInstance = nullptr;

		// The active openxr session handle
		XrSession m_xrSession = XR_NULL_HANDLE;

		// The current session state
		XrSessionState m_xrSessionState = XR_SESSION_STATE_UNKNOWN;

		// Whether special depth handling is enabled via an extension
		bool m_bDepthHandling = false;

		// Current view configuration type (e.g. STEREO for vr)
		XrViewConfigurationType m_xrViewConfigurationType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO;

		// Cache of view configuration views - holds texture information such as recommended and max extents (width, height)
		std::vector< XrViewConfigurationView > m_vecConfigViews;

		// Cache of views - holds fov and pose info for each view
		std::vector< XrView > m_vecViews;

		// Cache of swapchains. Each swapchain is a pair for both color and depth
		std::vector< Swapchain > m_vecSwapchains;

		// The most recent predicted display time from the last library render call
		XrTime m_xrPredictedDisplayTime = 0;

		// The most recent predicted display period from the last library render call
		XrTime m_xrPredictedDisplayPeriod = 0;

		// The active session's reference space
		XrSpace m_xrReferenceSpace = XR_NULL_HANDLE;

		// The app's reference space
		XrSpace m_xrAppSpace = XR_NULL_HANDLE;

		// Holds the app callbacks that will be called after acquire swapchain
		std::vector< RenderImageCallback * > m_vecAcquireSwapchainImageCallbacks;

		// Holds the app callbacks that will be called after wait swapchain
		std::vector< RenderImageCallback * > m_vecWaitSwapchainImageCallbacks;

		// Holds the app callbacks that will be called after release swapchain
		std::vector< RenderImageCallback * > m_vecReleaseSwapchainImageCallbacks;

		/// <summary>
		/// Removes an app register render callback
		/// </summary>
		/// <param name="vecRenderImageCallbacks">The vector container for the callbacks to check (separate for acquire, wait and release)</param>
		/// <param name="pRenderImageCallback">The callback to remove</param>
		inline void DeregisterRenderImageCallback( std::vector< RenderImageCallback * > &vecRenderImageCallbacks, RenderImageCallback *pRenderImageCallback )
		{
			vecRenderImageCallbacks.erase( std::remove( vecRenderImageCallbacks.begin(), vecRenderImageCallbacks.end(), pRenderImageCallback ), vecRenderImageCallbacks.end() );
			vecRenderImageCallbacks.shrink_to_fit();
		}

		/// <summary>
		/// Executes app registered render callbacks
		/// </summary>
		/// <param name="vecRenderImageCallbacks">The vector container for the callbacks to call (separate for acquire, wait and release)</param>
		/// <param name="unSwapchainIndex">The current swapchain index</param>
		/// <param name="unImageIndex">The current image/texture index in the swapchain to render to</param>
		inline void ExecuteRenderImageCallbacks( std::vector< RenderImageCallback * > &vecRenderImageCallbacks, uint32_t unSwapchainIndex, uint32_t unImageIndex )
		{
			for ( auto &renderCallback : vecRenderImageCallbacks )
			{
				renderCallback->fnCallback( unSwapchainIndex, unImageIndex );
			}
		}
	};

} // namespace oxr
