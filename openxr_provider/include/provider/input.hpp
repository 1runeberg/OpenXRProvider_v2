/* Copyright 2021, 2022, 2023 Rune Berg (GitHub: https://github.com/1runeberg, Twitter: https://twitter.com/1runeberg, YouTube: https://www.youtube.com/@1RuneBerg)
 *
 *  SPDX-License-Identifier: MIT
 *
 *  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *  DAMAGE.
 *
 */

#pragma once
#include "common.hpp"
#include "interaction_profiles.hpp"
#include <map>

namespace oxr
{
	class Session;
	struct ActionSet;
	struct Action;

	/// <summary>
	/// Callback function for openxr actions - will be called if actionstate has changed since the last input frame
	/// or is active for pose actions
	/// </summary>
	typedef void ( *Callback_InputAction )( Action *, uint32_t );

	/// <summary>
	/// Represents an openxr action and associated meta data
	/// </summary>
	struct Action
	{
		// openxr action type, this is set/required in the constructor
		XrActionType xrActionType = XR_ACTION_TYPE_BOOLEAN_INPUT;

		// openxr handle for the action, this is generated by the init() call
		XrAction xrActionHandle = XR_NULL_HANDLE;

		// actionset this action is linked to, this is set from the constructor
		ActionSet *pActionSet = nullptr;

		// function will be called when the action is triggered
		Callback_InputAction pfnCallback;

		// mutex for multi-threading locks
		std::mutex mutexActionState;

		// all possible actionset forms
		union ActionState
		{
			XrActionStateBoolean stateBoolean;
			XrActionStateFloat stateFloat;
			XrActionStateVector2f stateVector2f;
			XrActionStatePose statePose;
		};

		// actionstate related to this action - this is a vector representing number of subpaths
		// if there are none, use index 0
		std::vector< ActionState > vecActionStates;

		// the subpaths for this action, empty if none
		std::vector< XrPath > vecSubactionpaths;

		// action spaces if this is a pose action - this is a vector representing number of subpaths
		// if there are none, use index 0
		std::vector< XrSpace > vecActionSpaces;

		/// <summary>
		/// Constructor - this creates an action struct with the required callback and action type
		/// no openxr action is actually generated until a call to Init() is made
		/// </summary>
		/// <param name="actionType">Type of action</param>
		/// <param name="callback">Function to call if new actionstate is available for this action</param>
		Action( XrActionType actionType, Callback_InputAction callback )
			: xrActionType( actionType )
			, pfnCallback( callback )
		{
		}

		~Action();

		/// <summary>
		/// Returns the availability of this action (from latest  action state)
		/// </summary>
		/// <param name="unActionStateIndex">Index for the actionstate vector representing number of subpaths, use 0 if none</param>
		/// <returns>Whether this action is active in the current input frame or not</returns>
		bool IsActive( uint32_t unActionStateIndex = 0 );
		void SetActionStateType( uint32_t unActionStateIndex = 0 );

		/// <summary>
		/// Creates an openxr action and fills in the openxr handle for this action
		/// </summary>
		/// <param name="xrInstance">The active openxr instance</param>
		/// <param name="pActionSet">Pointer to the actionset this objecti s to be linked to</param>
		/// <param name="sName">Name of the action, note do not use any special characters other than underscore</param>
		/// <param name="sLocalizedName">Localized name of the action</param>
		/// <param name="vecSubpaths">Subpaths for this action (if any - e.g. /user/hand/left)</param>
		/// <param name="pOtherInfo">Any other info via extensions</param>
		/// <returns>The result of trying to create an openxr action from the runtime</returns>
		XrResult Init( XrInstance xrInstance, ActionSet *pActionSet, std::string sName, std::string sLocalizedName, std::vector< std::string > vecSubpaths = {}, void *pOtherInfo = nullptr );

		/// <summary>
		/// Adds a subaction path (e.g. "/user/hand/left") to this action
		/// </summary>
		/// <param name="outSubactionPaths">Out parameter - XrPath(s) for hte provided string subaction paths</param>
		/// <param name="xrInstance">The active openxr instance</param>
		/// <param name="sPath">The subaction path in string form (e.g. "/user/hand/left")</param>
		/// <returns>The result of creating Xrpaths from the openxr runtime</returns>
		XrResult AddSubActionPath( std::vector< XrPath > &outSubactionPaths, XrInstance xrInstance, std::string sPath );
	};

	/// <summary>
	/// Represents an openxr actionset () and its associated meta data
	/// these are collections of actions that can be activated based on game state
	/// (e.g. one actionset for locomotion and another for ui handling)
	/// you can optionally provide a priority and other info (e.g. via extensions)
	/// </summary>
	struct ActionSet
	{
		// openxr handle generated by the runtime when calling init()
		XrActionSet xrActionSetHandle = XR_NULL_HANDLE;

		// current priority of this actionset
		uint32_t unPriority = 0;

		// actions linked ot this actionset
		std::vector< Action * > vecActions;

		ActionSet() {}
		~ActionSet()
		{
			if ( xrActionSetHandle != XR_NULL_HANDLE )
			{
				xrDestroyActionSet( xrActionSetHandle );
			}
		}

		/// <summary>
		/// Creates an openxr actionset
		/// </summary>
		/// <param name="xrInstance">The active openxr instance</param>
		/// <param name="sName">Name of this actionset. Don't use any special characters other than an underscore</param>
		/// <param name="sLocalizedName">Localized name of this actionset - will be encoded in utf8</param>
		/// <param name="unPriority">The starting priority for this actionset. This can be changed during runtime via extensions</param>
		/// <param name="pOtherInfo">Other info when creating this actionset - optional, via extensions</param>
		/// <returns></returns>
		XrResult Init( XrInstance xrInstance, std::string sName, std::string sLocalizedName, uint32_t unPriority = 0, void *pOtherInfo = nullptr )
		{
			assert( xrInstance != XR_NULL_HANDLE );

			if ( xrActionSetHandle != XR_NULL_HANDLE )
				return XR_SUCCESS;

			XrActionSetCreateInfo xrActionSetCreateInfo { XR_TYPE_ACTION_SET_CREATE_INFO };
			xrActionSetCreateInfo.next = pOtherInfo;
			xrActionSetCreateInfo.priority = unPriority;
			std::strncpy( xrActionSetCreateInfo.actionSetName, sName.c_str(), XR_MAX_ACTION_SET_NAME_SIZE );
			std::strncpy( xrActionSetCreateInfo.localizedActionSetName, sLocalizedName.c_str(), XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE );

			XrResult xrResult = xrCreateActionSet( xrInstance, &xrActionSetCreateInfo, &xrActionSetHandle );

			if ( !XR_UNQUALIFIED_SUCCESS( xrResult ) )
			{
				LogError( LOG_CATEGORY_INPUT, "Error creating actionset %s : %s", sName.c_str(), XrEnumToString( xrResult ) );
				return xrResult;
			}

			LogInfo( LOG_CATEGORY_INPUT, "Actionset created (%s) : %s", sName.c_str(), sLocalizedName.c_str() );
			return XR_SUCCESS;
		}
	};

	class Session;

	/// <summary>
	/// Input handler class - encapsulates all openxr input calls and provides an easier interface to them
	/// including maintaining any necessary state and/or doing correct calls in the appropriate sequence(s)
	/// without losing any functionality or flexibility
	/// </summary>
	class Input
	{
	  public:
		/// <summary>
		/// Constructor - pass in an active openxr instance and optional log level here
		/// </summary>
		/// <param name="pInstance">Valid and running openxr instance</param>
		/// <param name="eLoglevel">Severity level for logging</param>
		Input( oxr::Instance *pInstance, ELogLevel eLoglevel = ELogLevel::LogInfo );

		~Input();

		/// <summary>
		/// Initialize input with a valid openxr session
		/// </summary>
		/// <param name="pSession">Valid openxr session - need not be runnign at this point</param>
		void Init( oxr::Session *pSession );

		/// <summary>
		/// Convenience function to properly create an openxr actionset
		/// </summary>
		/// <param name="outActionSet">Out parameter - Pointer actionset struct</param>
		/// <param name="sName">Name of the actionset, no special characters allowed here othe than an underscore</param>
		/// <param name="sLocalizedName">Localized name of the actionset</param>
		/// <param name="unPriority">Starting priority level - may only be adjusted once running via extensions</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when trying to create an actionset with given parameters</returns>
		XrResult CreateActionSet( ActionSet *outActionSet, std::string sName, std::string sLocalizedName, uint32_t unPriority = 0, void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to properly create an openxr action
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct</param>
		/// <param name="pActionSet">Pointer to the actionset that the new action will be linked to</param>
		/// <param name="sName">Name of the action, no special characters allowed here othe than an underscore</param>
		/// <param name="sLocalizedName">Localize name of the action</param>
		/// <param name="vecSubpaths">Optional subpaths in strign form (e.g. "user/hand/left")</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create an action with given parameters</returns>
		XrResult CreateAction( Action *outAction, ActionSet *pActionSet, std::string sName, std::string sLocalizedName, std::vector< std::string > vecSubpaths = {}, void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to properly create an openxr action space (for pose actions only)
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct with a pose action type</param>
		/// <param name="poseInSpace">Offset pose from base space (usually app sapce)</param>
		/// <param name="subpath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create an action space with given parameters</returns>
		XrResult CreateActionSpace( Action *outAction, XrPosef *poseInSpace, std::string subpath = "", void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to automatically create openxr action spaces for pose actions with subpaths
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct with a pose action type and subpaths</param>
		/// <param name="poseInSpace">Offset pose from base space (usually app sapce)</param>
		/// <param name="pOtherInfo">>Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create action spaces with given parameters</returns>
		XrResult CreateActionSpaces( Action *outAction, XrPosef *poseInSpace, void *pOtherInfo = nullptr );

		/// <summary>
		/// Adds a binding to a controller struct
		/// </summary>
		/// <param name="controller">Out parameter - controller struct to attach the binding to, if a base controller, it will add to all "supported controllers" defined for it</param>
		/// <param name="action">The action to bind to the controller input</param>
		/// <param name="hand">Hand (left/right)</param>
		/// <param name="component">Component of the controller for this binding (e.g. thumbstick)</param>
		/// <param name="qualifier">Optional qualifier (e.g. None, click, touch)</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create the binding paths for the specific controller(s)</returns>
		XrResult AddBinding( Controller *controller, XrAction action, XrHandEXT hand, Controller::Component component, Controller::Qualifier qualifier );

		/// <summary>
		/// Adds a binding to a controller struct. This allows for providign full binding paths. Note that this path is unchecked at this point, openxr runtime may reject during suggestbindings() if
		/// invalid
		/// </summary>
		/// <param name="controller">Out parameter - controller struct to attach the binding to, if a base controller, it will add to all "supported controllers" defined for it</param>
		/// <param name="action">The action to bind to the controller input</param>
		/// <param name="sFullBindingPath">Full binding path - check openxr spec and/or ext spec for the correct binding (e.g. "/user/hand/left/input/menu/click")</param>
		/// <returns>>Result of operation from the openxr runtime when attempting to create the binding paths for the specific controller(s)</returns>
		XrResult AddBinding( Controller *controller, XrAction action, std::string sFullBindingPath );

		/// <summary>
		/// Suggests all bindings added via AddBinding() to the openxr runtime
		/// </summary>
		/// <param name="controller">Pointer to controller struct representing the controller, or in the case of a base controller, all controllers supported by it</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of the suggest binding operation from the runtime</returns>
		XrResult SuggestBindings( Controller *controller, void *pOtherInfo );

		/// <summary>
		/// Converts a given c++ string to an openxr path/handle
		/// </summary>
		/// <param name="string">The string to convert</param>
		/// <param name="xrPath">Out arameter - XrPath</param>
		/// <returns>Result of the conversion from the openxr runtime</returns>
		XrResult StringToXrPath( const char *string, XrPath *xrPath );

		/// <summary>
		/// Converts a valid openxr path to a c++ string
		/// </summary>
		/// <param name="outString">Out parameter - the string that will capture the conversion</param>
		/// <param name="xrPath">Valid openxr path</param>
		/// <returns>Result of the conversion from the openxr runtime</returns>
		XrResult XrPathToString( std::string &outString, XrPath *xrPath );

		/// <summary>
		/// Adds an actionset for the next input sync with the runtime
		/// </summary>
		/// <param name="pActionSet">Pointer to the actionset struct to add for the sync</param>
		/// <param name="subpath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <returns>Result of adding the actionset for sync</returns>
		XrResult AddActionsetForSync( ActionSet *pActionSet, std::string subpath = "" );

		/// <summary>
		/// Removes an actionset for the next input sync with the runtime
		/// </summary>
		/// <param name="pActionSet">Pointer to the actionset struct to remove for the sync</param>
		/// <param name="subpath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <returns>Result of removing the actionset for sync</returns>
		XrResult RemoveActionsetForSync( ActionSet *pActionSet, std::string subpath );

		/// <summary>
		/// Attaches actionsets in the session
		/// </summary>
		/// <param name="arrActionSets">Array of actionsets to attach to the openxr session</param>
		/// <param name="unActionSetCount">number of actionsets in the array</param>
		/// <returns></returns>
		XrResult AttachActionSetsToSession( XrActionSet *arrActionSets, uint32_t unActionSetCount );

		/// <summary>
		/// Processes all input and calls action callback if triggered during input frame - can be safely run in a separate thread
		/// </summary>
		/// <returns>Any result from the input check loop the runtime</returns>
		XrResult ProcessInput();

		/// <summary>
		/// Retrieves the pose for a pose action with the provided predicted display time
		/// </summary>
		/// <param name="outSpaceLocation">Output parameter - space location to hold the result</param>
		/// <param name="pAction">Pointer to an action struct of type, pose</param>
		/// <param name="unSpaceIndex">Index to vector of spaces for the pose action space representing number of subpaths, 0 if none</param>
		/// <param name="xrTime">Predicted time to check pose for</param>
		/// <returns>Result from the openxr runtime of getting the current space location of a pose action</returns>
		XrResult GetActionPose( XrSpaceLocation *outSpaceLocation, Action *pAction, uint32_t unSpaceIndex, XrTime xrTime );

		/// <summary>
		/// Retrieves the actionstate of an action in the current input frame
		/// </summary>
		/// <param name="pAction">Pointer to an input action (any action other than haptic/vibration)</param>
		/// <returns>Result of retrieving hte actionstate for the provided action from the runtime</returns>
		XrResult GetActionState( Action *pAction );

		/// <summary>
		/// Retrieve the current active interaction profile (controller) as reported by the openxr runtime
		/// </summary>
		/// <param name="sUserPath">The user path to check (e.g. "/user/hand/left")</param>
		/// <returns>Result of check the current interaction profile (controller) from the currently active openxr runtime</returns>
		const char *GetCurrentInteractionProfile( const char *sUserPath );

		/// <summary>
		/// generate a haptic pulse with the frequency, duration, amplitude and frequency provided - also have common default settigns for convenience
		/// </summary>
		/// <param name="xrAction">Action handle of a haptic openxr action</param>
		/// <param name="subPath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <param name="nDuration">Duration in nanoseconds to run the haptics for</param>
		/// <param name="fAmplitude">Amplitude of the haptics between 0.0f to 1.0f</param>
		/// <param name="fFrequency">Frequency of the vibration in Hz</param>
		/// <returns></returns>
		XrResult GenerateHaptic( XrAction xrAction, XrPath subPath = XR_NULL_PATH, uint64_t nDuration = XR_MIN_HAPTIC_DURATION, float fAmplitude = 0.5f, float fFrequency = XR_FREQUENCY_UNSPECIFIED );

	  private:
		// Current severity for logging
		ELogLevel m_eMinLogLevel = ELogLevel::LogInfo;

		// Category to use for logging
		std::string m_sLogCategory = LOG_CATEGORY_INPUT;

		// Pointer to instance state from the Provider class
		Instance *m_pInstance = nullptr;

		// Pointer to a provider session object
		Session *m_pSession = nullptr;

		// Active action sets (XrActiveactionSet structs), this is internally kept in sync with m_vecActiveActionSets
		std::vector< XrActiveActionSet > m_vecXrActiveActionSets;

		// Active action sets (ActionSet struct pointers), this is internally kept in sync with m_vecXrActiveActionSets
		std::vector< ActionSet * > m_vecActiveActionSets;
	};

} // namespace oxr
