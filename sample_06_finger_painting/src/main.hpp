/* Copyright 2021, 2022, 2023 Rune Berg (GitHub: https://github.com/1runeberg, Twitter: https://twitter.com/1runeberg, YouTube: https://www.youtube.com/@1RuneBerg)
 *
 *  SPDX-License-Identifier: MIT
 *
 *  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *  DAMAGE.
 *
 */

// App defines
#define APP_NAME "sample_06_finger_painting"
#define ENGINE_NAME "openxr_provider"
#define LOG_CATEGORY_DEMO "OpenXRProviderDemo"

// Generated by cmake by populating project_config.h.in
#include "project_config.h"

#include <cstdlib>
#include <iomanip>
#include <iostream>

#include <openxr_provider.h>
#include <xrvk/xrvk.hpp>

#include "xrvk/xrvk.hpp"

// Event data packet sent by the openxr runtime during polling
XrEventDataBaseHeader *g_xrEventDataBaseheader = nullptr;


// Pointer to session handling object of the openxr provider library
oxr::Session *g_pSession = nullptr;

// Current openxr session state
XrSessionState g_sessionState = XR_SESSION_STATE_UNKNOWN;

// Latest openxr framestate - this is filled in on the render call
XrFrameState m_xrFrameState { XR_TYPE_FRAME_STATE };

// Projection viewss and layers to be rendered
std::vector< XrCompositionLayerProjectionView > g_vecFrameLayerProjectionViews;
std::vector< XrCompositionLayerBaseHeader * > g_vecFrameLayers;

// Pointer to the the xrvk renderer class
std::unique_ptr< xrvk::Render > g_pRender = nullptr;

// Hand tracking extension implementation, if present
oxr::ExtHandTracking *g_extHandTracking = nullptr;

// FB Passthrough extnesion implementation, if present
oxr::ExtFBPassthrough *g_extFBPassthrough = nullptr;

// Skybox manipulation vars
bool g_bSkyboxScalingActivated = false;
float g_fSkyboxScaleGestureDistanceOnActivate = 0.0f;

// Passthrough adjustments
bool g_bSaturationAdjustmentActivated = false;
float g_fSaturationValueOnActivation = 0.0f;
float g_fCurrentSaturationValue = 0.0f;

// Clap mechanic and passthrough effects
bool g_bClapActive = false;
uint16_t g_unPassthroughFXCycleStage = 0;

enum class EPassthroughFXMode
{
	EPassthroughFXMode_None = 0,
	EPassthroughFXMode_EdgeOn = 1,
	EPassthroughFXMode_Amber = 2,
	EPassthroughFXMode_Purple = 3,
	EPassthroughMode_Max
} g_eCurrentPassthroughFXMode;


// Gesture constants
static const float k_fGestureActivationThreshold = 0.025f;
static const float k_fClapActivationThreshold = 0.07f;
static const float k_fSkyboxScalingStride = 0.05f;
static const float k_fSaturationAdjustmentStride = 0.1f;


// Painting constants
// Cube vertices for finger painting
constexpr XrVector3f LBB { -0.5f, -0.5f, -0.5f };
constexpr XrVector3f LBF { -0.5f, -0.5f, 0.5f };
constexpr XrVector3f LTB { -0.5f, 0.5f, -0.5f };
constexpr XrVector3f LTF { -0.5f, 0.5f, 0.5f };
constexpr XrVector3f RBB { 0.5f, -0.5f, -0.5f };
constexpr XrVector3f RBF { 0.5f, -0.5f, 0.5f };
constexpr XrVector3f RTB { 0.5f, 0.5f, -0.5f };
constexpr XrVector3f RTF { 0.5f, 0.5f, 0.5f };
constexpr XrVector3f colorCyan { 0, 1, 1 };

std::vector< Shapes::Vertex > g_vecPaintCubeVertices = {
	CUBE_SIDE( LTB, LBF, LBB, LTB, LTF, LBF, colorCyan ) // -X
	CUBE_SIDE( RTB, RBB, RBF, RTB, RBF, RTF, colorCyan ) // +X
	CUBE_SIDE( LBB, LBF, RBF, LBB, RBF, RBB, colorCyan ) // -Y
	CUBE_SIDE( LTB, RTB, RTF, LTB, RTF, LTF, colorCyan ) // +Y
	CUBE_SIDE( LBB, RBB, RTB, LBB, RTB, LTB, colorCyan ) // -Z
	CUBE_SIDE( LBF, LTF, RTF, LBF, RTF, RBF, colorCyan ) // +Z
};

// Reference shape for painting
Shapes::Shape *g_pReferencePaint = nullptr;


/**
 * These are utility functions for the extensions we will be using in this demo
 */
void PopulateHandShapes( Shapes::Shape *shapePalm )
{
	assert( g_pRender );
	assert( shapePalm );

	// a cube per joint per hand - we'll match the indices with the hand tracking extension's
	// so we can easily refer to them later on to update the current tracked poses
	uint32_t unTotalHandJoints = XR_HAND_JOINT_COUNT_EXT * 2;
	g_pRender->vecShapes.resize( unTotalHandJoints );

	// zero out the scale so cubes won't immediately appear until after the first frame of poses come in
	shapePalm->scale = { 0.0f, 0.0f, 0.0f };

	// XR_HAND_JOINT_PALM_EXT (0) - Use as a reference
	g_pRender->vecShapes[ XR_HAND_JOINT_PALM_EXT ] = shapePalm;

	// left hand will use the first XR_HAND_JOINT_COUNT_EXT indices
	// right hand will use specHandJointIndex + XR_HAND_JOINT_COUNT_EXT indices
	for ( uint32_t i = 1; i < unTotalHandJoints; i++ )
	{
		g_pRender->vecShapes[ i ] = shapePalm->Duplicate();
	}
}

void UpdateHandJoints( XrHandEXT hand, XrHandJointLocationEXT *handJoints )
{
	uint8_t unOffset = hand == XR_HAND_LEFT_EXT ? 0 : XR_HAND_JOINT_COUNT_EXT;

	for ( uint32_t i = 0; i < XR_HAND_JOINT_COUNT_EXT; i++ )
	{
		if ( ( handJoints[ i ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 )
		{
			g_pRender->vecShapes[ i + unOffset ]->pose = handJoints[ i ].pose;
			g_pRender->vecShapes[ i + unOffset ]->scale = { handJoints[ i ].radius, handJoints[ i ].radius, handJoints[ i ].radius };
		}
	}
}

void UpdateHandTrackingPoses( XrFrameState *frameState )
{
	if ( g_extHandTracking )
	{
		// Update the hand joints poses for this frame
		g_extHandTracking->LocateHandJoints( XR_HAND_LEFT_EXT, g_pSession->GetAppSpace(), frameState->predictedDisplayTime );
		g_extHandTracking->LocateHandJoints( XR_HAND_RIGHT_EXT, g_pSession->GetAppSpace(), frameState->predictedDisplayTime );

		// Retrieve updated hand poses
		XrHandJointLocationsEXT *leftHand = g_extHandTracking->GetHandJointLocations( XR_HAND_LEFT_EXT );
		XrHandJointLocationsEXT *rightHand = g_extHandTracking->GetHandJointLocations( XR_HAND_RIGHT_EXT );

		// Finally, update cube poses representing the hand joints
		if ( leftHand->isActive )
			UpdateHandJoints( XR_HAND_LEFT_EXT, leftHand->jointLocations );

		if ( rightHand->isActive )
			UpdateHandJoints( XR_HAND_RIGHT_EXT, g_extHandTracking->GetHandJointLocations( XR_HAND_RIGHT_EXT )->jointLocations );
	}
}

void SetActionPaintCurrentState( XrHandEXT hand )
{
	// Check if hand tracking is available
	if ( g_extHandTracking )
	{
		// Get latest hand joints
		XrHandJointLocationsEXT *joints = g_extHandTracking->GetHandJointLocations( hand );

		// Check if index tip and thumb tips have valid locations
		if ( joints->isActive && ( joints->jointLocations[ XR_HAND_JOINT_INDEX_TIP_EXT ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 &&
			 ( joints->jointLocations[ XR_HAND_JOINT_THUMB_TIP_EXT ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 )
		{
			// Paint gesture - if index and thumb tips meet
			float fDistance = 0.0f;
			XrVector3f_Distance( &fDistance, &joints->jointLocations[ XR_HAND_JOINT_INDEX_TIP_EXT ].pose.position, &joints->jointLocations[ XR_HAND_JOINT_THUMB_TIP_EXT ].pose.position );

			if ( fDistance < k_fGestureActivationThreshold )
			{
				// Paint from the index tip
				Shapes::Shape *newPaint = g_pReferencePaint->Duplicate();
				newPaint->pose = joints->jointLocations[ XR_HAND_JOINT_INDEX_TIP_EXT ].pose;
				g_pRender->vecShapes.push_back( newPaint );
			}
		}
	}
}

bool IsTwoHandedGestureActive(
	XrHandJointEXT leftJointA,
	XrHandJointEXT leftJointB,
	XrHandJointEXT rightJointA,
	XrHandJointEXT rightJointB,
	XrVector3f *outReferencePosition_Left,
	XrVector3f *outReferencePosition_Right,
	bool *outActivated,
	float *fCacheValue )
{
	// Get latest hand joints
	XrHandJointLocationsEXT *leftHand = g_extHandTracking->GetHandJointLocations( XR_HAND_LEFT_EXT );
	XrHandJointLocationsEXT *rightHand = g_extHandTracking->GetHandJointLocations( XR_HAND_RIGHT_EXT );

	XrHandJointLocationEXT *leftJoints = leftHand->jointLocations;
	XrHandJointLocationEXT *rightJoints = rightHand->jointLocations;

	// Check if both left and right hands are tracking
	// and the provided joint a and joint b on both hands have valid positions
	if ( leftHand->isActive && rightHand->isActive && ( leftJoints[ leftJointA ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 &&
		 ( leftJoints[ leftJointB ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 && ( rightJoints[ rightJointA ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 &&
		 ( rightJoints[ rightJointB ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 )
	{
		// Check gesture
		float fDistance = 0.0f;

		*outReferencePosition_Left = leftJoints[ leftJointB ].pose.position;
		XrVector3f_Distance( &fDistance, &leftJoints[ leftJointA ].pose.position, outReferencePosition_Left );

		if ( fDistance < k_fGestureActivationThreshold )
		{
			*outReferencePosition_Right = rightJoints[ rightJointB ].pose.position;
			XrVector3f_Distance( &fDistance, &rightJoints[ rightJointA ].pose.position, outReferencePosition_Right );

			if ( fDistance < k_fGestureActivationThreshold )
			{
				*outActivated = true;
				return true;
			}
		}
	}

	*outActivated = false;
	*fCacheValue = 0.0f;
	return false;
}

bool IsSkyboxScalingActive( XrVector3f *outThumbPosition_Left, XrVector3f *outThumbPosition_Right )
{
	// Gesture - middle and thumb tips are touching on both hands
	return IsTwoHandedGestureActive(
		XR_HAND_JOINT_MIDDLE_TIP_EXT,
		XR_HAND_JOINT_THUMB_TIP_EXT,
		XR_HAND_JOINT_MIDDLE_TIP_EXT,
		XR_HAND_JOINT_THUMB_TIP_EXT,
		outThumbPosition_Left,
		outThumbPosition_Right,
		&g_bSkyboxScalingActivated,
		&g_fSkyboxScaleGestureDistanceOnActivate );
}

bool IsSaturationAdjustmentActive( XrVector3f *outThumbPosition_Left, XrVector3f *outThumbPosition_Right )
{
	// Gesture - ring and thumb tips are touching on both hands
	return IsTwoHandedGestureActive(
		XR_HAND_JOINT_RING_TIP_EXT,
		XR_HAND_JOINT_THUMB_TIP_EXT,
		XR_HAND_JOINT_RING_TIP_EXT,
		XR_HAND_JOINT_THUMB_TIP_EXT,
		outThumbPosition_Left,
		outThumbPosition_Right,
		&g_bSaturationAdjustmentActivated,
		&g_fSaturationValueOnActivation );
}

void ScaleSkybox()
{
	// Check for required extensions
	if ( g_extHandTracking == nullptr )
		return;

	// Check if gesture was activated on a previous frame
	bool bGestureActivedOnPreviousFrame = g_bSkyboxScalingActivated;

	// Check if gesture is active in this frame
	XrVector3f leftThumb, rightThumb;
	if ( IsSkyboxScalingActive( &leftThumb, &rightThumb ) )
	{
		// Gesture was activated on this frame, cache the distance
		if ( !bGestureActivedOnPreviousFrame )
		{
			XrVector3f_Distance( &g_fSkyboxScaleGestureDistanceOnActivate, &leftThumb, &rightThumb );
		}

		// Scale skybox based on distance and stride
		float currentDistance = 0.0f;
		XrVector3f_Distance( &currentDistance, &leftThumb, &rightThumb );

		float fGestureDistanceFromPreviousFrame = currentDistance - g_fSkyboxScaleGestureDistanceOnActivate;
		if ( abs( fGestureDistanceFromPreviousFrame ) < k_fSkyboxScalingStride )
			return;

		float fScaleFactor = fGestureDistanceFromPreviousFrame * k_fSkyboxScalingStride;
		g_pRender->skybox->currentScale.x += fScaleFactor;
		g_pRender->skybox->currentScale.y = g_pRender->skybox->currentScale.z = g_pRender->skybox->currentScale.x;
	}
}

void AdjustPassthroughSaturation()
{
	// Check for required extensions
	if ( g_extFBPassthrough == nullptr || g_extHandTracking == nullptr )
		return;

	// Check if gesture was activated on a previous frame
	bool bGestureActivedOnPreviousFrame = g_bSaturationAdjustmentActivated;

	// Check if gesture is active in this frame
	XrVector3f leftThumb, rightThumb;
	if ( IsSaturationAdjustmentActive( &leftThumb, &rightThumb ) )
	{
		// Gesture was activated on this frame, cache the distance
		if ( !bGestureActivedOnPreviousFrame )
		{
			XrVector3f_Distance( &g_fSaturationValueOnActivation, &leftThumb, &rightThumb );
		}

		// Adjust saturation based on distance and stride
		float currentDistance = 0.0f;
		XrVector3f_Distance( &currentDistance, &leftThumb, &rightThumb );

		float fGestureDistanceFromPreviousFrame = currentDistance - g_fSaturationValueOnActivation;
		if ( abs( fGestureDistanceFromPreviousFrame ) < k_fSaturationAdjustmentStride )
			return;

		g_fCurrentSaturationValue = fGestureDistanceFromPreviousFrame * k_fSaturationAdjustmentStride * 100;
		g_fCurrentSaturationValue = g_fCurrentSaturationValue < 0.0f ? 0.0f : g_fCurrentSaturationValue;
		g_extFBPassthrough->SetModeToBCS( 0.0f, 1.0f, g_fCurrentSaturationValue );
	}
}

void CyclePassthroughFX()
{
	switch ( g_eCurrentPassthroughFXMode )
	{
		case EPassthroughFXMode::EPassthroughFXMode_None:
			// Enable edges
			g_extFBPassthrough->SetModeToDefault();
			g_extFBPassthrough->SetPassThroughEdgeColor( { 0.0f, 1.0f, 1.0f, 1.0f } );
			g_eCurrentPassthroughFXMode = EPassthroughFXMode::EPassthroughFXMode_EdgeOn;
			break;
		case EPassthroughFXMode::EPassthroughFXMode_EdgeOn:
			// Set to amber
			g_extFBPassthrough->SetModeToColorMap( true, true, false );
			g_eCurrentPassthroughFXMode = EPassthroughFXMode::EPassthroughFXMode_Amber;
			break;
		case EPassthroughFXMode::EPassthroughFXMode_Amber:
			// Set to purple
			g_extFBPassthrough->SetModeToColorMap( true, false, true );
			g_eCurrentPassthroughFXMode = EPassthroughFXMode::EPassthroughFXMode_Purple;
			break;
		case EPassthroughFXMode::EPassthroughFXMode_Purple:
		case EPassthroughFXMode::EPassthroughMode_Max:
		default:
			// Reset
			g_extFBPassthrough->SetModeToDefault();
			g_eCurrentPassthroughFXMode = EPassthroughFXMode::EPassthroughFXMode_None;
			break;
	}
}

void Clap()
{
	// Check for required extensions
	if ( g_extFBPassthrough == nullptr || g_extHandTracking == nullptr )
		return;

	// Get latest hand joints
	XrHandJointLocationsEXT *leftHand = g_extHandTracking->GetHandJointLocations( XR_HAND_LEFT_EXT );
	XrHandJointLocationsEXT *rightHand = g_extHandTracking->GetHandJointLocations( XR_HAND_RIGHT_EXT );

	// Gesture: palms of left and right hands are touching
	if ( leftHand->isActive && rightHand->isActive && ( leftHand->jointLocations[ XR_HAND_JOINT_PALM_EXT ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 &&
		 ( rightHand->jointLocations[ XR_HAND_JOINT_PALM_EXT ].locationFlags & XR_SPACE_LOCATION_POSITION_VALID_BIT ) != 0 )
	{
		float fDistance = 0.0f;
		XrVector3f_Distance( &fDistance, &leftHand->jointLocations[ XR_HAND_JOINT_PALM_EXT ].pose.position, &rightHand->jointLocations[ XR_HAND_JOINT_PALM_EXT ].pose.position );

		if ( fDistance < k_fClapActivationThreshold )
		{
			// Gesture activated - set the previous clap state for checking on successive frame
			g_bClapActive = true;
			return;
		}

		// Hands are active but not in clap gesture
		if ( g_bClapActive )
		{
			// If previous clap state is true, then perform action
			CyclePassthroughFX();

			g_bClapActive = false;
			return;
		}
	}

	// Hands were inactive or not giving valid data
	g_bClapActive = false;
}

/**
 * These are utility functions to check game loop conditions
 * For android, we need to be able to check the app state as well
 * so we can process android events data at the appropriate times.
 */
#ifdef XR_USE_PLATFORM_ANDROID
static void app_handle_cmd( struct android_app *app, int32_t cmd )
{
	oxr::AndroidAppState *appState = ( oxr::AndroidAppState * )app->userData;

	switch ( cmd )
	{
		case APP_CMD_RESUME:
		{
			appState->Resumed = true;
			break;
		}
		case APP_CMD_PAUSE:
		{
			appState->Resumed = false;
			break;
		}
		case APP_CMD_DESTROY:
		{
			appState->NativeWindow = NULL;
			break;
		}
		case APP_CMD_INIT_WINDOW:
		{
			appState->NativeWindow = app->window;
			break;
		}
		case APP_CMD_TERM_WINDOW:
		{
			appState->NativeWindow = NULL;
			break;
		}
	}
}

bool CheckGameLoopExit( oxr::Provider *oxrProvider ) { return oxrProvider->Instance()->androidApp->onAppCmd = app_handle_cmd; }

#else
bool CheckGameLoopExit( oxr::Provider *oxrProvider ) { return oxrProvider->Session()->GetState() != XR_SESSION_STATE_EXITING; }
#endif

/**
 * These are callback functions that would be registered with the
 * openxr provider to handle render calls at appropriate times in
 * the application.
 */
void PreRender_Callback( uint32_t unSwapchainIndex, uint32_t unImageIndex )
{
	if ( m_xrFrameState.shouldRender )
	{
		// Hand tracking updates
		UpdateHandTrackingPoses( &m_xrFrameState );

		// Painting updates
		SetActionPaintCurrentState( XR_HAND_LEFT_EXT );
		SetActionPaintCurrentState( XR_HAND_RIGHT_EXT );

		// Skybox scaling
		ScaleSkybox();

		// Render
		g_pRender->BeginRender( g_pSession, g_vecFrameLayerProjectionViews, &m_xrFrameState, unSwapchainIndex, unImageIndex, 0.1f, 10000.f );

		// Passthrough adjustments
		AdjustPassthroughSaturation();
		Clap();
	}
}

void PostRender_Callback( uint32_t unSwapchainIndex, uint32_t unImageIndex ) { g_pRender->EndRender(); }
