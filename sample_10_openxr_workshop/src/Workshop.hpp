/* Copyright 2021, 2022, 2023 Rune Berg (GitHub: https://github.com/1runeberg, Twitter: https://twitter.com/1runeberg, YouTube: https://www.youtube.com/@1RuneBerg)
 *
 *  SPDX-License-Identifier: MIT
 *
 *  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *  DAMAGE.
 *
 */

#pragma once

// Generated by cmake by populating project_config.h.in
#include "project_config.h"

// Openxr template app
#include <app.hpp>

// App defines
#define APP_NAME "openxr_workshop"
#define ENGINE_NAME "openxr_provider"
#define LOG_CATEGORY_APP "openxr_workshop"

using namespace oxr;

namespace oxa
{
	class Workshop : public XrApp
	{
	  public:
		// Create app from template
		Workshop();

		// Destroy app
		~Workshop();

		// Interfaces - XrApp
#ifdef XR_USE_PLATFORM_ANDROID
		XrResult Start( struct android_app *app ) override;
#else
		XrResult Start() override;
#endif

		// Game loop condition
#ifdef XR_USE_PLATFORM_ANDROID
		static void app_handle_cmd( struct android_app *app, int32_t cmd )
		{
			oxr::AndroidAppState *appState = ( oxr::AndroidAppState * )app->userData;

			switch ( cmd )
			{
				case APP_CMD_RESUME:
				{
					appState->Resumed = true;
					break;
				}
				case APP_CMD_PAUSE:
				{
					appState->Resumed = false;
					break;
				}
				case APP_CMD_DESTROY:
				{
					appState->NativeWindow = NULL;
					break;
				}
				case APP_CMD_INIT_WINDOW:
				{
					appState->NativeWindow = app->window;
					break;
				}
				case APP_CMD_TERM_WINDOW:
				{
					appState->NativeWindow = NULL;
					break;
				}
			}
		}

		bool CheckGameLoopExit( oxr::Provider *oxrProvider ) { return oxrProvider->Instance()->androidApp->onAppCmd = app_handle_cmd; }

#else
		bool CheckGameLoopExit( oxr::Provider *oxrProvider ) { return oxrProvider->Session()->GetState() != XR_SESSION_STATE_EXITING; }
#endif

		// Game loop
		void RunGameLoop();

		// Session handling
		void ProcessSessionStateChanges();

		// Callback handling
		void PrepareRender( uint32_t unSwapchainIndex, uint32_t unImageIndex );
		void SubmitRender( uint32_t unSwapchainIndex, uint32_t unImageIndex );
		void RegisterRenderCallbacks();

		// Custom graphics pipelines
		void PrepareCustomShapesPipelines();
		void PrepareCustomGraphicsPipelines();

		// ... custom pipelines here ...
		void PrepareFloorGridPipeline();

		// Renderables
		void AddSceneAssets();

		// Input handling
		XrResult CreateActionsets();
		XrResult CreateActions();
		XrResult SuggestBindings();
		XrResult AttachActionsets();
		XrResult AddActionsetsForSync();

		// Actionsets
		struct actionsets
		{
			oxr::ActionSet *locomotion = nullptr;
		} workshopActionsets;

		// Actions
		struct actions
		{
			oxr::Action *vec2SmoothLoco = nullptr;
		} workshopActions;

		// Locomotion parameters
		struct locomotion_params
		{
			float fSmoothActivationPoint = 0.5f;

			float fSmoothFwd = 0.1f;
			float fSmoothBack = 0.1f;
			float fSmoothLeft = 0.075f;
			float fSmoothRight = 0.075f;
		} locomotionParams;

		// Android events handling
#ifdef XR_USE_PLATFORM_ANDROID
		void AndroidPoll();
#endif

	  private:
		bool m_bProcessRenderFrame = false;
		bool m_bProcessInputFrame = false;

		oxr::RenderImageCallback releaseCallback;
		oxr::RenderImageCallback waitCallback;

		// custom assets
		uint32_t m_unFloorSpotIdx = 0;
	};

} // namespace oxa
